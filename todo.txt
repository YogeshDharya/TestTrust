I need to pay a lot of attention towards the individual testing of each file like 
trying to instantiate a class in the constant package should give message 
should we use a single metrocardexception as the root , as the only exception or should create something entirely new like internal server error ?
Predictable Hidden Tests (for Intermediate badge):

check for TODO: tasks if any 
./run.sh sample_input/input1.txt
CommandFactory: Your commented line shows CommandFactory.createCommand(parts[0], parts)â€”use this instead of createCommand(parts[0]). 
Some commands (e.g., BalanceCommand) need args for parameters (cardId, amount). The single-arg version may fail hidden tests.
passengerType enum has two constructors with one being package private
command invoker is still absent should It be the main class using it or should we have some controller ?
command I in a separate package even if it would be the only interface in there ?
same goes for factory , strategy etc ?
command interface takes in service interface not service class 
Station's unique id is also int so hope we have some string attribute 2 over there cause the intput file 
has one referring to the station which can be either Airport or the Central Station
28th september 2025 19:47isko badla nahi tu 
We are using int as of now as the unique id of a given model class object
if we are using command pattern then they should be in sync with our services since they are also expected to have 
the business logic presently we have balance(), checkIn() and getSummarry() method in the metroservice interface->class itself 
Also repository should be present as a 
I think that it is still possible to create an instance for the metroservice(frog) which has a getInstance() 
what could be the reason for having passenger count in the 
station ? 
And if cards are expected to belong to passengers then 
shouldn't we have their userId passengerId in the definition 
of the card model class ? 
Should the station know which all passengers are present there for 
the metro 
I am asking this because considering the cardinality or 
multiplicity I thought the MetroCard itself 
serves as the bridging class created owing to the Many to 
Many relationship between the station and the passengers
Also if passengers are expected to have a summarry of their 
bill thing than why don't we have a passenger class in the 
model package ?
I have two repository classes now but may one more will be needed 
State management is done by constants ? 
Whose observing the state in case Obsever design pattern ITS NOT USED 
getSummarry should be a command instead of being a station member method ? 
I think the tests should be more granular instead of having MetroCardTest.java 
hidden test cases should not be having individual methods/files HOLD UP this can't be 

Low balance (triggers re-charge + fee).
Return journeys (50% discount).
Invalid inputs (unknown card/station, malformed types).
Empty files or large data-sets (~1000 commands).
Test these in JUnit to pass hidden cases.


Design Patterns (for Advanced badge):
Command Pattern (Behavioral): Encapsulates each command (BALANCE, CHECK_IN, PRINT_SUMMARY) as an object with execute(). Allows easy extension (e.g., add CANCEL command) and decoupling from the parser.

Interface: Command with execute(MetroService service).
Concrete: BalanceCommand, CheckInCommand, PrintSummaryCommand.


Factory Pattern (Creation-al): Creates command objects dynamically based on input, promoting loose coupling.

Class: CommandFactory with createCommand(String commandName, String[] args).


Strategy Pattern (Behavioral): Handles variable fares by passenger type, allowing easy addition of new types (e.g., STUDENT=75).

Interface: FareStrategy with calculateFare(boolean isReturn).
Concrete: AdultFareStrategy, SeniorFareStrategy, KidFareStrategy.
Factory: FareStrategyFactory to get strategy by PassengerType.


Singleton Pattern (Creational): Ensures a single MetroService instance for global state management (HashMaps), preventing multiple instances in larger systems.

Implemented in MetroService with getInstance().


Builder Pattern (Creational): Used for SummaryDTO to construct complex outputs fluently, especially with sorted lists.
Composite Pattern (Structural): Implicit in Station's passengerCounts map and getSummary (treats passenger types as components of a station summary).